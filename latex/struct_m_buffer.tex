\hypertarget{struct_m_buffer}{}\section{M\+Buffer Struct Reference}
\label{struct_m_buffer}\index{M\+Buffer@{M\+Buffer}}


\hyperlink{struct_m_buffer}{M\+Buffer} a contiguous buffer.  




{\ttfamily \#include $<$buffer.\+hpp$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{struct_m_buffer_a4f12e1ae3dc9acf4739f4cb8df49cb98}{M\+Buffer} (const std\+::size\+\_\+t cap)
\item 
\hyperlink{struct_m_buffer_a7afd94b5e8b2a26ffab8ede1aef06f07}{$\sim$\+M\+Buffer} ()
\item 
void $\ast$ \hyperlink{struct_m_buffer_a76fda1089c0abb54ac72977228245725}{data} ()
\item 
std\+::size\+\_\+t \hyperlink{struct_m_buffer_a9b3db2bdbcadcb68478cc5edc6164432}{size} ()
\item 
std\+::size\+\_\+t \hyperlink{struct_m_buffer_acadde0f7cb85b05602a61aa8e3277369}{capacity} ()
\item 
void $\ast$ \hyperlink{struct_m_buffer_a3a520754e8335f75136135caea741960}{next\+Available} ()
\item 
\hyperlink{struct_m_buffer}{M\+Buffer} \& \hyperlink{struct_m_buffer_a6b1a469848174ab1925e964034408c07}{empty} ()
\item 
\hyperlink{struct_m_buffer}{M\+Buffer} \& \hyperlink{struct_m_buffer_abb2765e8b761bbd0c17fdd7bdaada053}{append} (void $\ast$\hyperlink{struct_m_buffer_a76fda1089c0abb54ac72977228245725}{data}, std\+::size\+\_\+t len)
\item 
\mbox{\Hypertarget{struct_m_buffer_a29b005cac5a7d2a7690145e8c3121e6f}\label{struct_m_buffer_a29b005cac5a7d2a7690145e8c3121e6f}} 
\hyperlink{struct_m_buffer}{M\+Buffer} \& {\bfseries set\+Size} (std\+::size\+\_\+t n)
\item 
std\+::string \hyperlink{struct_m_buffer_af3600a4125123ee2b0e62fb84fd758a0}{to\+String} ()
\item 
bool \hyperlink{struct_m_buffer_a629f84798448ae301df28d3d54520135}{contains} (void $\ast$ptr)
\item 
\mbox{\Hypertarget{struct_m_buffer_ae84bf1ea3e993bef7967ea4685fd8adc}\label{struct_m_buffer_ae84bf1ea3e993bef7967ea4685fd8adc}} 
bool {\bfseries contains} (char $\ast$ptr)
\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{struct_m_buffer_ae9f75c8701f5cae42b8384ae4edb1ad1}\label{struct_m_buffer_ae9f75c8701f5cae42b8384ae4edb1ad1}} 
void $\ast$ {\bfseries mem\+Ptr}
\item 
\mbox{\Hypertarget{struct_m_buffer_a508d55df27bae34cd8ed486c0b226ab1}\label{struct_m_buffer_a508d55df27bae34cd8ed486c0b226ab1}} 
char $\ast$ \hyperlink{struct_m_buffer_a508d55df27bae34cd8ed486c0b226ab1}{c\+Ptr}
\begin{DoxyCompactList}\small\item\em points to the start of the memory slab managed by the instance \end{DoxyCompactList}\item 
\mbox{\Hypertarget{struct_m_buffer_a98d22bf882aa625b6cf24cfc2f34be5e}\label{struct_m_buffer_a98d22bf882aa625b6cf24cfc2f34be5e}} 
std\+::size\+\_\+t \hyperlink{struct_m_buffer_a98d22bf882aa625b6cf24cfc2f34be5e}{length\+\_\+}
\begin{DoxyCompactList}\small\item\em same as mem\+Ptr but makes it easier in debugger to see whats in the buffer \end{DoxyCompactList}\item 
\mbox{\Hypertarget{struct_m_buffer_a69e539d29403f2c50eec2cf75819549e}\label{struct_m_buffer_a69e539d29403f2c50eec2cf75819549e}} 
std\+::size\+\_\+t {\bfseries capacity\+\_\+}
\item 
\mbox{\Hypertarget{struct_m_buffer_a6e6bea091fb15983fd4f36a51150cabf}\label{struct_m_buffer_a6e6bea091fb15983fd4f36a51150cabf}} 
std\+::size\+\_\+t \hyperlink{struct_m_buffer_a6e6bea091fb15983fd4f36a51150cabf}{size\+\_\+}
\begin{DoxyCompactList}\small\item\em the capacity of the buffer, the value used for the malloc call \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Friends}
\begin{DoxyCompactItemize}
\item 
boost\+::asio\+::const\+\_\+buffer \hyperlink{struct_m_buffer_a7c4fdebaff03d8d95c7915a9da1f8490}{mb\+\_\+as\+\_\+const\+\_\+buffer} (\hyperlink{struct_m_buffer}{M\+Buffer} \&bm)
\item 
boost\+::asio\+::mutable\+\_\+buffer \hyperlink{struct_m_buffer_a13c4f6e4208776d422e20509d873404d}{mb\+\_\+as\+\_\+mutable\+\_\+buffer} (\hyperlink{struct_m_buffer}{M\+Buffer} \&bm)
\item 
std\+::ostream \& \hyperlink{struct_m_buffer_abdaf184bb8d819d10f4676a9782e7bec}{operator$<$$<$} (std\+::ostream \&os, \hyperlink{struct_m_buffer}{M\+Buffer} \&b)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\hyperlink{struct_m_buffer}{M\+Buffer} a contiguous buffer. 

\hyperlink{struct_m_buffer}{M\+Buffer} class wraps a contigous buffer an provides manipulation methods. Once constructed the Mbuffer iinstance \char`\"{}own\char`\"{} the raw memory. \hyperlink{struct_m_buffer}{M\+Buffer} destructor releases the raw memory. 

\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{struct_m_buffer_a4f12e1ae3dc9acf4739f4cb8df49cb98}\label{struct_m_buffer_a4f12e1ae3dc9acf4739f4cb8df49cb98}} 
\index{M\+Buffer@{M\+Buffer}!M\+Buffer@{M\+Buffer}}
\index{M\+Buffer@{M\+Buffer}!M\+Buffer@{M\+Buffer}}
\subsubsection{\texorpdfstring{M\+Buffer()}{MBuffer()}}
{\footnotesize\ttfamily M\+Buffer\+::\+M\+Buffer (\begin{DoxyParamCaption}\item[{const std\+::size\+\_\+t}]{cap }\end{DoxyParamCaption})}

Constructor -\/ give it a slab of memory to manage Let the \hyperlink{struct_m_buffer}{M\+Buffer} constructor allocate the memory -\/ but tell it howmuch \mbox{\Hypertarget{struct_m_buffer_a7afd94b5e8b2a26ffab8ede1aef06f07}\label{struct_m_buffer_a7afd94b5e8b2a26ffab8ede1aef06f07}} 
\index{M\+Buffer@{M\+Buffer}!````~M\+Buffer@{$\sim$\+M\+Buffer}}
\index{````~M\+Buffer@{$\sim$\+M\+Buffer}!M\+Buffer@{M\+Buffer}}
\subsubsection{\texorpdfstring{$\sim$\+M\+Buffer()}{~MBuffer()}}
{\footnotesize\ttfamily M\+Buffer\+::$\sim$\+M\+Buffer (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

destrtuctor -\/ frees the memory the instance is managing 

\subsection{Member Function Documentation}
\mbox{\Hypertarget{struct_m_buffer_abb2765e8b761bbd0c17fdd7bdaada053}\label{struct_m_buffer_abb2765e8b761bbd0c17fdd7bdaada053}} 
\index{M\+Buffer@{M\+Buffer}!append@{append}}
\index{append@{append}!M\+Buffer@{M\+Buffer}}
\subsubsection{\texorpdfstring{append()}{append()}}
{\footnotesize\ttfamily \hyperlink{struct_m_buffer}{M\+Buffer} \& M\+Buffer\+::append (\begin{DoxyParamCaption}\item[{void $\ast$}]{data,  }\item[{std\+::size\+\_\+t}]{len }\end{DoxyParamCaption})}

adds (by copying) data to the buffer starting at the first unsed byte \mbox{\Hypertarget{struct_m_buffer_acadde0f7cb85b05602a61aa8e3277369}\label{struct_m_buffer_acadde0f7cb85b05602a61aa8e3277369}} 
\index{M\+Buffer@{M\+Buffer}!capacity@{capacity}}
\index{capacity@{capacity}!M\+Buffer@{M\+Buffer}}
\subsubsection{\texorpdfstring{capacity()}{capacity()}}
{\footnotesize\ttfamily std\+::size\+\_\+t M\+Buffer\+::capacity (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

capacity of the buffer -\/ max value of size \mbox{\Hypertarget{struct_m_buffer_a629f84798448ae301df28d3d54520135}\label{struct_m_buffer_a629f84798448ae301df28d3d54520135}} 
\index{M\+Buffer@{M\+Buffer}!contains@{contains}}
\index{contains@{contains}!M\+Buffer@{M\+Buffer}}
\subsubsection{\texorpdfstring{contains()}{contains()}}
{\footnotesize\ttfamily bool M\+Buffer\+::contains (\begin{DoxyParamCaption}\item[{void $\ast$}]{ptr }\end{DoxyParamCaption})}

Detremines if an address value (pointer) is within the address range of the the buffer ie buffer.\+dada() $<$ = ptr $<$ buffer.\+data() + buffer.\+capacity(); or, should it be buffer.\+dada() $<$ = ptr $<$ buffer.\+data() + buffer.\+size(); \mbox{\Hypertarget{struct_m_buffer_a76fda1089c0abb54ac72977228245725}\label{struct_m_buffer_a76fda1089c0abb54ac72977228245725}} 
\index{M\+Buffer@{M\+Buffer}!data@{data}}
\index{data@{data}!M\+Buffer@{M\+Buffer}}
\subsubsection{\texorpdfstring{data()}{data()}}
{\footnotesize\ttfamily void $\ast$ M\+Buffer\+::data (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

gets a pointer to the start of the memory slab being managed by the instance \mbox{\Hypertarget{struct_m_buffer_a6b1a469848174ab1925e964034408c07}\label{struct_m_buffer_a6b1a469848174ab1925e964034408c07}} 
\index{M\+Buffer@{M\+Buffer}!empty@{empty}}
\index{empty@{empty}!M\+Buffer@{M\+Buffer}}
\subsubsection{\texorpdfstring{empty()}{empty()}}
{\footnotesize\ttfamily \hyperlink{struct_m_buffer}{M\+Buffer} \& M\+Buffer\+::empty (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Resets the buffer so that it is again an empty buffer \mbox{\Hypertarget{struct_m_buffer_a3a520754e8335f75136135caea741960}\label{struct_m_buffer_a3a520754e8335f75136135caea741960}} 
\index{M\+Buffer@{M\+Buffer}!next\+Available@{next\+Available}}
\index{next\+Available@{next\+Available}!M\+Buffer@{M\+Buffer}}
\subsubsection{\texorpdfstring{next\+Available()}{nextAvailable()}}
{\footnotesize\ttfamily void $\ast$ M\+Buffer\+::next\+Available (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

returns a pointer to the next available unused position in the buffer \mbox{\Hypertarget{struct_m_buffer_a9b3db2bdbcadcb68478cc5edc6164432}\label{struct_m_buffer_a9b3db2bdbcadcb68478cc5edc6164432}} 
\index{M\+Buffer@{M\+Buffer}!size@{size}}
\index{size@{size}!M\+Buffer@{M\+Buffer}}
\subsubsection{\texorpdfstring{size()}{size()}}
{\footnotesize\ttfamily std\+::size\+\_\+t M\+Buffer\+::size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

gets the size of used portion of the buffer \mbox{\Hypertarget{struct_m_buffer_af3600a4125123ee2b0e62fb84fd758a0}\label{struct_m_buffer_af3600a4125123ee2b0e62fb84fd758a0}} 
\index{M\+Buffer@{M\+Buffer}!to\+String@{to\+String}}
\index{to\+String@{to\+String}!M\+Buffer@{M\+Buffer}}
\subsubsection{\texorpdfstring{to\+String()}{toString()}}
{\footnotesize\ttfamily std\+::string M\+Buffer\+::to\+String (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Returns a string that has the same value as the used portion of the buffer 

\subsection{Friends And Related Function Documentation}
\mbox{\Hypertarget{struct_m_buffer_a7c4fdebaff03d8d95c7915a9da1f8490}\label{struct_m_buffer_a7c4fdebaff03d8d95c7915a9da1f8490}} 
\index{M\+Buffer@{M\+Buffer}!mb\+\_\+as\+\_\+const\+\_\+buffer@{mb\+\_\+as\+\_\+const\+\_\+buffer}}
\index{mb\+\_\+as\+\_\+const\+\_\+buffer@{mb\+\_\+as\+\_\+const\+\_\+buffer}!M\+Buffer@{M\+Buffer}}
\subsubsection{\texorpdfstring{mb\+\_\+as\+\_\+const\+\_\+buffer}{mb\_as\_const\_buffer}}
{\footnotesize\ttfamily boost\+::asio\+::const\+\_\+buffer mb\+\_\+as\+\_\+const\+\_\+buffer (\begin{DoxyParamCaption}\item[{\hyperlink{struct_m_buffer}{M\+Buffer} \&}]{bm }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [friend]}}

converts an \hyperlink{struct_m_buffer}{M\+Buffer} to a boost\+::asio\+::const\+\_\+buffer \mbox{\Hypertarget{struct_m_buffer_a13c4f6e4208776d422e20509d873404d}\label{struct_m_buffer_a13c4f6e4208776d422e20509d873404d}} 
\index{M\+Buffer@{M\+Buffer}!mb\+\_\+as\+\_\+mutable\+\_\+buffer@{mb\+\_\+as\+\_\+mutable\+\_\+buffer}}
\index{mb\+\_\+as\+\_\+mutable\+\_\+buffer@{mb\+\_\+as\+\_\+mutable\+\_\+buffer}!M\+Buffer@{M\+Buffer}}
\subsubsection{\texorpdfstring{mb\+\_\+as\+\_\+mutable\+\_\+buffer}{mb\_as\_mutable\_buffer}}
{\footnotesize\ttfamily boost\+::asio\+::mutable\+\_\+buffer mb\+\_\+as\+\_\+mutable\+\_\+buffer (\begin{DoxyParamCaption}\item[{\hyperlink{struct_m_buffer}{M\+Buffer} \&}]{bm }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [friend]}}

converts an \hyperlink{struct_m_buffer}{M\+Buffer} to a boost\+::asio\+::mutable\+\_\+buffer \mbox{\Hypertarget{struct_m_buffer_abdaf184bb8d819d10f4676a9782e7bec}\label{struct_m_buffer_abdaf184bb8d819d10f4676a9782e7bec}} 
\index{M\+Buffer@{M\+Buffer}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!M\+Buffer@{M\+Buffer}}
\subsubsection{\texorpdfstring{operator$<$$<$}{operator<<}}
{\footnotesize\ttfamily std\+::ostream\& operator$<$$<$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{os,  }\item[{\hyperlink{struct_m_buffer}{M\+Buffer} \&}]{b }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [friend]}}

outputs the content to a stream 

The documentation for this struct was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
marvin/buffer/buffer.\+hpp\item 
marvin/buffer/buffer.\+cpp\end{DoxyCompactItemize}
