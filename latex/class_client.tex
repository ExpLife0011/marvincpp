\hypertarget{class_client}{}\section{Client Class Reference}
\label{class_client}\index{Client@{Client}}


{\ttfamily \#include $<$client.\+hpp$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_client_afdde66898aa2cbfbdace6098de0f0800}{Client} (boost\+::asio\+::io\+\_\+service \&io, Http\+Header\+::\+Scheme\+Type scheme, std\+::string server, std\+::string port)
\item 
\hyperlink{class_client_a17e2ff6c5015bea27259c47b5948c2e7}{Client} (boost\+::asio\+::io\+\_\+service \&io, std\+::string uri)
\item 
\hyperlink{class_client_a71e7eb95dbfbf747395904e04370c3b3}{Client} (boost\+::asio\+::io\+\_\+service \&io, \hyperlink{class_connection_interface}{Connection\+Interface} $\ast$conn)
\item 
\mbox{\Hypertarget{class_client_a831c9bf9b4d6907ec23a04025810693f}\label{class_client_a831c9bf9b4d6907ec23a04025810693f}} 
{\bfseries Client} (const \hyperlink{class_client}{Client} \&other)=delete
\item 
\mbox{\Hypertarget{class_client_a255f4905a3a0176a194e4a675d0a172b}\label{class_client_a255f4905a3a0176a194e4a675d0a172b}} 
\hyperlink{class_client}{Client} \& {\bfseries operator=} (const \hyperlink{class_client}{Client} \&)=delete
\item 
\mbox{\Hypertarget{class_client_a5886919756e3f0dcc4058ccb47ba44d6}\label{class_client_a5886919756e3f0dcc4058ccb47ba44d6}} 
Message\+Reader\+S\+Ptr {\bfseries get\+Response} ()
\item 
\mbox{\Hypertarget{class_client_af41106f498418bfd27f2acac18f154a5}\label{class_client_af41106f498418bfd27f2acac18f154a5}} 
void {\bfseries set\+Url} (std\+::string url)
\item 
\mbox{\Hypertarget{class_client_af1dd3726ed7b178f6adcdc97523388d3}\label{class_client_af1dd3726ed7b178f6adcdc97523388d3}} 
void {\bfseries set\+Content} (std\+::string \&content\+Str)
\item 
void \hyperlink{class_client_af87e3114d4bff798cc9f16169319b576}{set\+On\+Response} (Response\+Handler\+Callback\+Type cb)
\item 
void \hyperlink{class_client_a1d175afa24c28766e3955f7039183b6e}{set\+On\+Headers} (Response\+Handler\+Callback\+Type cb)
\item 
void \hyperlink{class_client_a73e292408e166316e14651941c92f615}{set\+On\+Data} (Client\+Data\+Handler\+Callback\+Type cb)
\item 
void \hyperlink{class_client_a7a272658b966e26a452eeaca461f8fd2}{async\+Connect} (Error\+Only\+Callback\+Type cb)
\item 
void \hyperlink{class_client_a7d9c259aa4e1262987eb3d4e909565e2}{async\+Write} (Message\+Base\+S\+Ptr request\+Message, Response\+Handler\+Callback\+Type cb)
\item 
void \hyperlink{class_client_a4cc4752e98a0466c1dcbfb6791f1e226}{async\+Write} (Message\+Base\+S\+Ptr request\+Message, std\+::string \&body\+\_\+str, Response\+Handler\+Callback\+Type cb)
\item 
\mbox{\Hypertarget{class_client_ac3481f3e23665c4a4ddabd03eec6575d}\label{class_client_ac3481f3e23665c4a4ddabd03eec6575d}} 
void {\bfseries async\+Write} (Message\+Base\+S\+Ptr request\+Message, M\+Buffer\+S\+Ptr body\+\_\+sptr, Response\+Handler\+Callback\+Type cb)
\item 
\mbox{\Hypertarget{class_client_a7048efd28cbe37f69fc9a607e2d07852}\label{class_client_a7048efd28cbe37f69fc9a607e2d07852}} 
void {\bfseries async\+Write} (Message\+Base\+S\+Ptr request\+Message, Buffer\+Chain\+S\+Ptr chain\+\_\+sptr, Response\+Handler\+Callback\+Type cb)
\item 
void \hyperlink{class_client_aecccd1b8c74dc9c0df4e211a0625391b}{async\+Write} (Message\+Base\+S\+Ptr request\+Message, F\+Buffer\+Shared\+Ptr body, Response\+Handler\+Callback\+Type cb)
\item 
void \hyperlink{class_client_a41a1654e97f9bd05ef1022076be0667c}{async\+Write\+Headers} (Message\+Base\+S\+Ptr request\+Message, Write\+Headers\+Callback\+Type cb)
\item 
void \hyperlink{class_client_a250fc2560b361f3fa3ef4a20061089d9}{async\+Write\+Body\+Data} (void $\ast$data\+Buffer, bool last, Write\+Body\+Data\+Callback\+Type cb)
\item 
void \hyperlink{class_client_ab55418abd09e5c887168d1fdf3bd9d1f}{async\+Write\+Trailers} (Message\+Base\+S\+Ptr request\+Message, Async\+Write\+Callback\+Type cb)
\item 
void \hyperlink{class_client_ae60322d424fa33d49cd88e6bee08e7af}{end} ()
\item 
void \hyperlink{class_client_a2ac4838875e743af25125d8b5c8eba09}{close} ()
\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_client_a65270d4bec13972dc19c3eeab2b9c7a3}\label{class_client_a65270d4bec13972dc19c3eeab2b9c7a3}} 
void {\bfseries internal\+Connect} ()
\item 
\mbox{\Hypertarget{class_client_ab9775fe0ef908d59a5ab17e27caa8fd8}\label{class_client_ab9775fe0ef908d59a5ab17e27caa8fd8}} 
void {\bfseries internal\+Write} ()
\item 
\mbox{\Hypertarget{class_client_ab58ce4f6c733f1ecf42e4aa4007f52b2}\label{class_client_ab58ce4f6c733f1ecf42e4aa4007f52b2}} 
void {\bfseries \+\_\+async\+\_\+write} (Message\+Base\+S\+Ptr request\+Message, Response\+Handler\+Callback\+Type cb)
\item 
\mbox{\Hypertarget{class_client_a299af80ea0a0a71458a7ca4c91bc6ae7}\label{class_client_a299af80ea0a0a71458a7ca4c91bc6ae7}} 
void {\bfseries put\+Headers\+Stuff\+In\+Buffer} ()
\item 
void \hyperlink{class_client_a6d0d6b3a672370c201a24c839c5f7382}{setup\+Url} (std\+::string url)
\item 
\mbox{\Hypertarget{class_client_a2a4105d8c58e9c8e2ca1919baca31026}\label{class_client_a2a4105d8c58e9c8e2ca1919baca31026}} 
void {\bfseries default\+Headers} ()
\item 
\mbox{\Hypertarget{class_client_aedea5f9f1f9fb7a8732dc982a0e629c9}\label{class_client_aedea5f9f1f9fb7a8732dc982a0e629c9}} 
void {\bfseries set\+Content\+Length} ()
\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_client_a714da8195cfe69bbb8fa1f254cfa53cd}\label{class_client_a714da8195cfe69bbb8fa1f254cfa53cd}} 
std\+::string {\bfseries \+\_\+url}
\item 
\mbox{\Hypertarget{class_client_ade1bbfabad2a418db11741f9d6aef1de}\label{class_client_ade1bbfabad2a418db11741f9d6aef1de}} 
std\+::string {\bfseries \+\_\+uri}
\item 
\mbox{\Hypertarget{class_client_a9080780007752190a708d566ed3a05f0}\label{class_client_a9080780007752190a708d566ed3a05f0}} 
std\+::string {\bfseries \+\_\+scheme}
\item 
\mbox{\Hypertarget{class_client_a70d16da0e37d8395bab50d56c82d6aef}\label{class_client_a70d16da0e37d8395bab50d56c82d6aef}} 
std\+::string {\bfseries \+\_\+server}
\item 
\mbox{\Hypertarget{class_client_a9b53e47e860f4656b348654643ddb76e}\label{class_client_a9b53e47e860f4656b348654643ddb76e}} 
std\+::string {\bfseries \+\_\+host}
\item 
\mbox{\Hypertarget{class_client_a0984cf4f6e5d4a99e72b7189ab50826f}\label{class_client_a0984cf4f6e5d4a99e72b7189ab50826f}} 
std\+::string {\bfseries \+\_\+host\+\_\+with\+\_\+port}
\item 
\mbox{\Hypertarget{class_client_a4671a4ffec3179a0ba4821b0d781b901}\label{class_client_a4671a4ffec3179a0ba4821b0d781b901}} 
std\+::string {\bfseries \+\_\+port}
\item 
\mbox{\Hypertarget{class_client_a1c8113f51275dbb67633548399595ddc}\label{class_client_a1c8113f51275dbb67633548399595ddc}} 
std\+::string {\bfseries \+\_\+path}
\item 
\mbox{\Hypertarget{class_client_a4f5a6400fbe272f8212a88155cf7deb5}\label{class_client_a4f5a6400fbe272f8212a88155cf7deb5}} 
Url\+::\+Query {\bfseries \+\_\+query}
\item 
\mbox{\Hypertarget{class_client_afdcff50a83d67c071ebac089b21b16a1}\label{class_client_afdcff50a83d67c071ebac089b21b16a1}} 
std\+::string {\bfseries \+\_\+query\+Str}
\item 
\mbox{\Hypertarget{class_client_a6461a9372edd60a8aba63ae5ccc082fb}\label{class_client_a6461a9372edd60a8aba63ae5ccc082fb}} 
boost\+::asio\+::io\+\_\+service \& {\bfseries \+\_\+io}
\item 
\mbox{\Hypertarget{class_client_a4a87fac91903111214bfc059a871a5ba}\label{class_client_a4a87fac91903111214bfc059a871a5ba}} 
Message\+Base\+S\+Ptr {\bfseries \+\_\+current\+\_\+request}
\item 
\mbox{\Hypertarget{class_client_ae61b6b1b65599c17c28f8627760ea684}\label{class_client_ae61b6b1b65599c17c28f8627760ea684}} 
M\+Buffer\+S\+Ptr {\bfseries \+\_\+body\+\_\+mbuffer\+\_\+sptr}
\item 
\mbox{\Hypertarget{class_client_abc69353f4a7afea1d9a485de18350c08}\label{class_client_abc69353f4a7afea1d9a485de18350c08}} 
F\+Buffer\+Shared\+Ptr {\bfseries \+\_\+body\+\_\+fbuffer\+\_\+sptr}
\item 
\mbox{\Hypertarget{class_client_a60ba27f037924a099b13dcbace4425cc}\label{class_client_a60ba27f037924a099b13dcbace4425cc}} 
std\+::shared\+\_\+ptr$<$ \hyperlink{class_message_writer}{Message\+Writer} $>$ {\bfseries \+\_\+wrtr}
\item 
\mbox{\Hypertarget{class_client_a27fdd6a6489468f01efa06f8376bf9bb}\label{class_client_a27fdd6a6489468f01efa06f8376bf9bb}} 
std\+::shared\+\_\+ptr$<$ \hyperlink{class_message_reader}{Message\+Reader} $>$ {\bfseries \+\_\+rdr}
\item 
\mbox{\Hypertarget{class_client_a4e06284228a92f6e91b00ef170fc6ae1}\label{class_client_a4e06284228a92f6e91b00ef170fc6ae1}} 
std\+::shared\+\_\+ptr$<$ \hyperlink{class_t_c_p_connection}{T\+C\+P\+Connection} $>$ {\bfseries \+\_\+conn\+\_\+shared\+\_\+ptr}
\item 
\mbox{\Hypertarget{class_client_a3291b49a7c5c40886e31aa05a562602f}\label{class_client_a3291b49a7c5c40886e31aa05a562602f}} 
\hyperlink{class_read_socket_interface}{Read\+Socket\+Interface} $\ast$ {\bfseries \+\_\+read\+Sock}
\item 
\mbox{\Hypertarget{class_client_a02e33df170f88dbda08fe9cd0b3a0025}\label{class_client_a02e33df170f88dbda08fe9cd0b3a0025}} 
std\+::function$<$ void(Marvin\+::\+Error\+Type \&err)$>$ {\bfseries \+\_\+go\+Cb}
\item 
\mbox{\Hypertarget{class_client_a8d085507b14c836cbda0749ca2decb56}\label{class_client_a8d085507b14c836cbda0749ca2decb56}} 
Response\+Handler\+Callback\+Type {\bfseries \+\_\+response\+\_\+handler}
\item 
\mbox{\Hypertarget{class_client_ab417dd0da30a89767811a717b5c6a14f}\label{class_client_ab417dd0da30a89767811a717b5c6a14f}} 
Response\+Handler\+Callback\+Type {\bfseries \+\_\+on\+\_\+headers\+\_\+handler}
\item 
\mbox{\Hypertarget{class_client_af785f3d2d211634bf74dd35c5b523f75}\label{class_client_af785f3d2d211634bf74dd35c5b523f75}} 
Client\+Data\+Handler\+Callback\+Type {\bfseries \+\_\+on\+\_\+data\+\_\+handler}
\end{DoxyCompactItemize}
\subsection*{Friends}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_client_abaaeecb3bd7e6e64684e894e64752cfc}\label{class_client_abaaeecb3bd7e6e64684e894e64752cfc}} 
std\+::string {\bfseries trace\+Client} (\hyperlink{class_client}{Client} \&client)
\item 
\mbox{\Hypertarget{class_client_ad5f4b9cead705423379f0778f53e9d20}\label{class_client_ad5f4b9cead705423379f0778f53e9d20}} 
std\+::string {\bfseries trace\+Request\+Message} (\hyperlink{class_message_base}{Message\+Base} \&request)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
This class implements an http client that can send a request message and wait for a response.

Two modes of transmission operation are provided for\+:


\begin{DoxyItemize}
\item send the entire request in a single call using async\+Write. This mode is best when either there is NO message body or the entire message body is available at the time the request transmission is started. In this mode the handler provided to async\+Write is passed a complete response including any body data.
\item send the request/message piecemeal -\/ headers, followed by multiple chunks of body, followed by trailers. This mode is intended to handle streaming of the body data to avoid latency or buffering large body. In this mode the handler for the incoming response message is provide by the set\+On\+Response\+Handler. The response handler should be set before any transmission is started. A complete response including body data is provided to this handler.
\end{DoxyItemize}

Two constructors are provided
\begin{DoxyItemize}
\item one will construct a non-\/connected client for which an explicit or implicit connect call will be required.
\item the other creates a client with an established connection.
\end{DoxyItemize}

Handlers or callbacks 

\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_client_afdde66898aa2cbfbdace6098de0f0800}\label{class_client_afdde66898aa2cbfbdace6098de0f0800}} 
\index{Client@{Client}!Client@{Client}}
\index{Client@{Client}!Client@{Client}}
\subsubsection{\texorpdfstring{Client()}{Client()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily Client\+::\+Client (\begin{DoxyParamCaption}\item[{boost\+::asio\+::io\+\_\+service \&}]{io,  }\item[{Http\+Header\+::\+Scheme\+Type}]{scheme,  }\item[{std\+::string}]{server,  }\item[{std\+::string}]{port }\end{DoxyParamCaption})}

Create a client that is not connected -\/ however give it the info it needs to try and establish a connection


\begin{DoxyParams}{Parameters}
{\em io} & -\/ an io service \\
\hline
{\em scheme} & of type Http\+Header\+::\+Scheme\+Type \\
\hline
{\em server} & -\/ a string like google.\+com \\
\hline
{\em port} & -\/ a string like \char`\"{}443\char`\"{} \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_client_a17e2ff6c5015bea27259c47b5948c2e7}\label{class_client_a17e2ff6c5015bea27259c47b5948c2e7}} 
\index{Client@{Client}!Client@{Client}}
\index{Client@{Client}!Client@{Client}}
\subsubsection{\texorpdfstring{Client()}{Client()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily Client\+::\+Client (\begin{DoxyParamCaption}\item[{boost\+::asio\+::io\+\_\+service \&}]{io,  }\item[{std\+::string}]{uri }\end{DoxyParamCaption})}

Create a client that is not connected -\/ however give a url it needs to try and establish a connection. 
\begin{DoxyParams}{Parameters}
{\em io} & -\/ an io service \\
\hline
{\em url} & -\/ a string like \char`\"{}https\+://username\+:password@www.\+google.\+com/path1/path2\+:433?one=1111\char`\"{} \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_client_a71e7eb95dbfbf747395904e04370c3b3}\label{class_client_a71e7eb95dbfbf747395904e04370c3b3}} 
\index{Client@{Client}!Client@{Client}}
\index{Client@{Client}!Client@{Client}}
\subsubsection{\texorpdfstring{Client()}{Client()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily Client\+::\+Client (\begin{DoxyParamCaption}\item[{boost\+::asio\+::io\+\_\+service \&}]{io,  }\item[{\hyperlink{class_connection_interface}{Connection\+Interface} $\ast$}]{conn }\end{DoxyParamCaption})}

Create a client with an established connection. In this case a call to connect will fail with an exception -\/ as it is a logic error 

\subsection{Member Function Documentation}
\mbox{\Hypertarget{class_client_a7a272658b966e26a452eeaca461f8fd2}\label{class_client_a7a272658b966e26a452eeaca461f8fd2}} 
\index{Client@{Client}!async\+Connect@{async\+Connect}}
\index{async\+Connect@{async\+Connect}!Client@{Client}}
\subsubsection{\texorpdfstring{async\+Connect()}{asyncConnect()}}
{\footnotesize\ttfamily void Client\+::async\+Connect (\begin{DoxyParamCaption}\item[{Error\+Only\+Callback\+Type}]{cb }\end{DoxyParamCaption})}

Connects to the target host



 \subsubsection*{implement connect }\mbox{\Hypertarget{class_client_a7d9c259aa4e1262987eb3d4e909565e2}\label{class_client_a7d9c259aa4e1262987eb3d4e909565e2}} 
\index{Client@{Client}!async\+Write@{async\+Write}}
\index{async\+Write@{async\+Write}!Client@{Client}}
\subsubsection{\texorpdfstring{async\+Write()}{asyncWrite()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily void Client\+::async\+Write (\begin{DoxyParamCaption}\item[{Message\+Base\+S\+Ptr}]{request\+Message,  }\item[{Response\+Handler\+Callback\+Type}]{cb }\end{DoxyParamCaption})}

Writes the complete message to the connected host inlcuding body and trailers (if there are any).

If not connected will perform a connect before transmitting the message. Will wait for a response and call the on\+Response\+Handler CB when the response is complete.

If the request is to have a body it must be already attached to the \hyperlink{class_message_interface}{Message\+Interface}. A content\+\_\+length header will be attached by the client.

If the request is to have NO body use this method with the request\+Message.\+body == nullptr; \mbox{\Hypertarget{class_client_a4cc4752e98a0466c1dcbfb6791f1e226}\label{class_client_a4cc4752e98a0466c1dcbfb6791f1e226}} 
\index{Client@{Client}!async\+Write@{async\+Write}}
\index{async\+Write@{async\+Write}!Client@{Client}}
\subsubsection{\texorpdfstring{async\+Write()}{asyncWrite()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily void Client\+::async\+Write (\begin{DoxyParamCaption}\item[{Message\+Base\+S\+Ptr}]{request\+Message,  }\item[{std\+::string \&}]{body\+\_\+str,  }\item[{Response\+Handler\+Callback\+Type}]{cb }\end{DoxyParamCaption})}

The following are three ways to add a body to a request. The first two take a string or a shared pointer to an \hyperlink{struct_m_buffer}{M\+Buffer} -\/ these are contiguous buffers and can be sent with a single async\+Write \mbox{\Hypertarget{class_client_aecccd1b8c74dc9c0df4e211a0625391b}\label{class_client_aecccd1b8c74dc9c0df4e211a0625391b}} 
\index{Client@{Client}!async\+Write@{async\+Write}}
\index{async\+Write@{async\+Write}!Client@{Client}}
\subsubsection{\texorpdfstring{async\+Write()}{asyncWrite()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily void Client\+::async\+Write (\begin{DoxyParamCaption}\item[{Message\+Base\+S\+Ptr}]{request\+Message,  }\item[{F\+Buffer\+Shared\+Ptr}]{body,  }\item[{Response\+Handler\+Callback\+Type}]{cb }\end{DoxyParamCaption})}

The \hyperlink{class_f_buffer}{F\+Buffer} is fragmented and requires multiple async\+Write operations to send it \mbox{\Hypertarget{class_client_a250fc2560b361f3fa3ef4a20061089d9}\label{class_client_a250fc2560b361f3fa3ef4a20061089d9}} 
\index{Client@{Client}!async\+Write\+Body\+Data@{async\+Write\+Body\+Data}}
\index{async\+Write\+Body\+Data@{async\+Write\+Body\+Data}!Client@{Client}}
\subsubsection{\texorpdfstring{async\+Write\+Body\+Data()}{asyncWriteBodyData()}}
{\footnotesize\ttfamily void Client\+::async\+Write\+Body\+Data (\begin{DoxyParamCaption}\item[{void $\ast$}]{data\+Buffer,  }\item[{bool}]{last,  }\item[{Write\+Body\+Data\+Callback\+Type}]{cb }\end{DoxyParamCaption})}

Transmits a block of body data -\/ the data should N\+OT be chunk encode that will be done within the call.


\begin{DoxyParams}{Parameters}
{\em data\+Buffer} & (type T\+BD) can also be nullptr \\
\hline
{\em last} & bool -\/ signals this is the last data\+Buffer and that the chunk trailer should be generated. \\
\hline
{\em cb} & -\/ handler to be called when operation complete.\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
-\/ async\+Write\+Body\+Data( nullptr, true, ....) is the normal way to
\begin{DoxyItemize}
\item signal end of data, as the caller may not know its e-\/o-\/d until after the last buffer is sent. Such a call still sends data on the connection
\begin{DoxyItemize}
\item the chunk encoding trailer. 
\end{DoxyItemize}
\end{DoxyItemize}
\end{DoxyNote}
\mbox{\Hypertarget{class_client_a41a1654e97f9bd05ef1022076be0667c}\label{class_client_a41a1654e97f9bd05ef1022076be0667c}} 
\index{Client@{Client}!async\+Write\+Headers@{async\+Write\+Headers}}
\index{async\+Write\+Headers@{async\+Write\+Headers}!Client@{Client}}
\subsubsection{\texorpdfstring{async\+Write\+Headers()}{asyncWriteHeaders()}}
{\footnotesize\ttfamily void Client\+::async\+Write\+Headers (\begin{DoxyParamCaption}\item[{Message\+Base\+S\+Ptr}]{request\+Message,  }\item[{Write\+Headers\+Callback\+Type}]{cb }\end{DoxyParamCaption})}

Sends the first line and headers of the request message only and expects any body data to be sent using async\+Write\+Body\+Data in which case the body will be \char`\"{}chunk\char`\"{} encoded and the headers will be completed to indicate this.

Dont use this method IF there is no body data, use async\+Write \mbox{\Hypertarget{class_client_ab55418abd09e5c887168d1fdf3bd9d1f}\label{class_client_ab55418abd09e5c887168d1fdf3bd9d1f}} 
\index{Client@{Client}!async\+Write\+Trailers@{async\+Write\+Trailers}}
\index{async\+Write\+Trailers@{async\+Write\+Trailers}!Client@{Client}}
\subsubsection{\texorpdfstring{async\+Write\+Trailers()}{asyncWriteTrailers()}}
{\footnotesize\ttfamily void Client\+::async\+Write\+Trailers (\begin{DoxyParamCaption}\item[{Message\+Base\+S\+Ptr}]{request\+Message,  }\item[{Async\+Write\+Callback\+Type}]{cb }\end{DoxyParamCaption})}

not yet implemented

This method should only be used if the transmission was started with a call to async\+Write\+Headers. The method async\+Write handles trailers automatically.

Sends the trailers that are present in the request\+Message -\/ trailers can be added to the message A\+F\+T\+ER transmission has started as the internals of this class do not inspect the trailers until this call nor does it keep a copy of the original request \mbox{\Hypertarget{class_client_a2ac4838875e743af25125d8b5c8eba09}\label{class_client_a2ac4838875e743af25125d8b5c8eba09}} 
\index{Client@{Client}!close@{close}}
\index{close@{close}!Client@{Client}}
\subsubsection{\texorpdfstring{close()}{close()}}
{\footnotesize\ttfamily void Client\+::close (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

close -\/ called to signal that connection\+::close has been received and that the net round trip should use a different connection for the next message. This invalidates \+\_\+connection, \+\_\+rdr, \+\_\+wrtr

-\/ not sure we need this -\/ just delete the client object \mbox{\Hypertarget{class_client_ae60322d424fa33d49cd88e6bee08e7af}\label{class_client_ae60322d424fa33d49cd88e6bee08e7af}} 
\index{Client@{Client}!end@{end}}
\index{end@{end}!Client@{Client}}
\subsubsection{\texorpdfstring{end()}{end()}}
{\footnotesize\ttfamily void Client\+::end (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Called to signal end-\/of-\/message. This function will (if necessary) add the chunk-\/encoding trailer. \mbox{\Hypertarget{class_client_a73e292408e166316e14651941c92f615}\label{class_client_a73e292408e166316e14651941c92f615}} 
\index{Client@{Client}!set\+On\+Data@{set\+On\+Data}}
\index{set\+On\+Data@{set\+On\+Data}!Client@{Client}}
\subsubsection{\texorpdfstring{set\+On\+Data()}{setOnData()}}
{\footnotesize\ttfamily void Client\+::set\+On\+Data (\begin{DoxyParamCaption}\item[{Client\+Data\+Handler\+Callback\+Type}]{cb }\end{DoxyParamCaption})}

Sets a handler to be called when a chunk of body data is available.

optional \mbox{\Hypertarget{class_client_a1d175afa24c28766e3955f7039183b6e}\label{class_client_a1d175afa24c28766e3955f7039183b6e}} 
\index{Client@{Client}!set\+On\+Headers@{set\+On\+Headers}}
\index{set\+On\+Headers@{set\+On\+Headers}!Client@{Client}}
\subsubsection{\texorpdfstring{set\+On\+Headers()}{setOnHeaders()}}
{\footnotesize\ttfamily void Client\+::set\+On\+Headers (\begin{DoxyParamCaption}\item[{Response\+Handler\+Callback\+Type}]{cb }\end{DoxyParamCaption})}

Sets a handler to be called when all headers have been received or if an error occurs while receiving a response message headers.

optional \mbox{\Hypertarget{class_client_af87e3114d4bff798cc9f16169319b576}\label{class_client_af87e3114d4bff798cc9f16169319b576}} 
\index{Client@{Client}!set\+On\+Response@{set\+On\+Response}}
\index{set\+On\+Response@{set\+On\+Response}!Client@{Client}}
\subsubsection{\texorpdfstring{set\+On\+Response()}{setOnResponse()}}
{\footnotesize\ttfamily void Client\+::set\+On\+Response (\begin{DoxyParamCaption}\item[{Response\+Handler\+Callback\+Type}]{cb }\end{DoxyParamCaption})}

Sets a handler to be called when a complete response message is received or if an error occurs while receiving a response message. \mbox{\Hypertarget{class_client_a6d0d6b3a672370c201a24c839c5f7382}\label{class_client_a6d0d6b3a672370c201a24c839c5f7382}} 
\index{Client@{Client}!setup\+Url@{setup\+Url}}
\index{setup\+Url@{setup\+Url}!Client@{Client}}
\subsubsection{\texorpdfstring{setup\+Url()}{setupUrl()}}
{\footnotesize\ttfamily void Client\+::setup\+Url (\begin{DoxyParamCaption}\item[{std\+::string}]{url }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



 sets the url for the request, parses the url into components and saves them in particular deduces
\begin{DoxyItemize}
\item scheme
\item host -\/ both with and without port appended
\item port
\item path/uri \subsubsection*{-\/ query string }
\end{DoxyItemize}

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
marvin/client/client.\+hpp\item 
marvin/client/client.\+cpp\end{DoxyCompactItemize}
