\hypertarget{class_f_buffer}{}\section{F\+Buffer Class Reference}
\label{class_f_buffer}\index{F\+Buffer@{F\+Buffer}}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_f_buffer_a3aac6ae74811d7c6d3902ad5c1fdcab3}{F\+Buffer} (\hyperlink{struct_m_buffer}{M\+Buffer} $\ast$mbuf)
\item 
\hyperlink{class_f_buffer_a89680be41fb35ea1b9591ca646713f2f}{F\+Buffer} (std\+::size\+\_\+t capacity)
\item 
\hyperlink{class_f_buffer_a4e490d569edada34d24a5b16da72fafc}{$\sim$\+F\+Buffer} ()
\item 
std\+::size\+\_\+t \hyperlink{class_f_buffer_ae5f30d510287df8185bc30ecfd80840e}{size} ()
\item 
\hyperlink{struct_m_buffer}{M\+Buffer} \& \hyperlink{class_f_buffer_a0987483eef377d599dcae38a6aac5236}{get\+M\+Buffer} ()
\item 
void \hyperlink{class_f_buffer_a64064a784e0ada0957d76db6c83b22fa}{copy\+In} (void $\ast$bytes, std\+::size\+\_\+t len)
\item 
void \hyperlink{class_f_buffer_aee2d12df78293e2b3e8da359e7d0a757}{add\+Fragment} (void $\ast$bytes, std\+::size\+\_\+t len)
\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_f_buffer_ac9dc209989dbda81840a3cfb96de77d5}\label{class_f_buffer_ac9dc209989dbda81840a3cfb96de77d5}} 
\hyperlink{struct_m_buffer}{M\+Buffer} $\ast$ {\bfseries \+\_\+container}
\item 
\mbox{\Hypertarget{class_f_buffer_af444abbf2078dfd307692e9102a066ab}\label{class_f_buffer_af444abbf2078dfd307692e9102a066ab}} 
std\+::vector$<$ \hyperlink{class_fragment}{Fragment} $>$ \hyperlink{class_f_buffer_af444abbf2078dfd307692e9102a066ab}{\+\_\+fragments}
\begin{DoxyCompactList}\small\item\em where all the fragments reside \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_f_buffer_a5cf37f4378a3f5d778f65786a9fed276}\label{class_f_buffer_a5cf37f4378a3f5d778f65786a9fed276}} 
std\+::size\+\_\+t \hyperlink{class_f_buffer_a5cf37f4378a3f5d778f65786a9fed276}{\+\_\+size}
\begin{DoxyCompactList}\small\item\em a list of fragments \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Friends}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_f_buffer_a2a832c78617be463503bceec23b2e773}\label{class_f_buffer_a2a832c78617be463503bceec23b2e773}} 
std\+::vector$<$ boost\+::asio\+::const\+\_\+buffer $>$ {\bfseries fb\+\_\+as\+\_\+const\+\_\+buffer\+\_\+sequence} (\hyperlink{class_f_buffer}{F\+Buffer} \&bm)
\item 
\mbox{\Hypertarget{class_f_buffer_a3e2bb2caacfd3d4795212913c14c277b}\label{class_f_buffer_a3e2bb2caacfd3d4795212913c14c277b}} 
std\+::vector$<$ boost\+::asio\+::mutable\+\_\+buffer $>$ {\bfseries fb\+\_\+as\+\_\+mutable\+\_\+buffer\+\_\+sequence} (\hyperlink{class_f_buffer}{F\+Buffer} \&bm)
\item 
\mbox{\Hypertarget{class_f_buffer_a96fce1073312fb0ff79ae8b2ae78451e}\label{class_f_buffer_a96fce1073312fb0ff79ae8b2ae78451e}} 
std\+::ostream \& {\bfseries operator$<$$<$} (std\+::ostream \&os, \hyperlink{class_f_buffer}{F\+Buffer} const \&b)
\end{DoxyCompactItemize}


\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_f_buffer_a3aac6ae74811d7c6d3902ad5c1fdcab3}\label{class_f_buffer_a3aac6ae74811d7c6d3902ad5c1fdcab3}} 
\index{F\+Buffer@{F\+Buffer}!F\+Buffer@{F\+Buffer}}
\index{F\+Buffer@{F\+Buffer}!F\+Buffer@{F\+Buffer}}
\subsubsection{\texorpdfstring{F\+Buffer()}{FBuffer()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily F\+Buffer\+::\+F\+Buffer (\begin{DoxyParamCaption}\item[{\hyperlink{struct_m_buffer}{M\+Buffer} $\ast$}]{mbuf }\end{DoxyParamCaption})}

Constructor that wraps an \hyperlink{struct_m_buffer}{M\+Buffer} -\/ the \hyperlink{class_f_buffer}{F\+Buffer} now \char`\"{}owns\char`\"{} the \hyperlink{struct_m_buffer}{M\+Buffer} and will free/delete it in the \hyperlink{class_f_buffer}{F\+Buffer}\textquotesingle{}s destructor \mbox{\Hypertarget{class_f_buffer_a89680be41fb35ea1b9591ca646713f2f}\label{class_f_buffer_a89680be41fb35ea1b9591ca646713f2f}} 
\index{F\+Buffer@{F\+Buffer}!F\+Buffer@{F\+Buffer}}
\index{F\+Buffer@{F\+Buffer}!F\+Buffer@{F\+Buffer}}
\subsubsection{\texorpdfstring{F\+Buffer()}{FBuffer()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily F\+Buffer\+::\+F\+Buffer (\begin{DoxyParamCaption}\item[{std\+::size\+\_\+t}]{capacity }\end{DoxyParamCaption})}

Constructore that hides the underlying \hyperlink{struct_m_buffer}{M\+Buffer} \mbox{\Hypertarget{class_f_buffer_a4e490d569edada34d24a5b16da72fafc}\label{class_f_buffer_a4e490d569edada34d24a5b16da72fafc}} 
\index{F\+Buffer@{F\+Buffer}!````~F\+Buffer@{$\sim$\+F\+Buffer}}
\index{````~F\+Buffer@{$\sim$\+F\+Buffer}!F\+Buffer@{F\+Buffer}}
\subsubsection{\texorpdfstring{$\sim$\+F\+Buffer()}{~FBuffer()}}
{\footnotesize\ttfamily F\+Buffer\+::$\sim$\+F\+Buffer (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Destructor -\/ will delete the managed \hyperlink{struct_m_buffer}{M\+Buffer} 

\subsection{Member Function Documentation}
\mbox{\Hypertarget{class_f_buffer_aee2d12df78293e2b3e8da359e7d0a757}\label{class_f_buffer_aee2d12df78293e2b3e8da359e7d0a757}} 
\index{F\+Buffer@{F\+Buffer}!add\+Fragment@{add\+Fragment}}
\index{add\+Fragment@{add\+Fragment}!F\+Buffer@{F\+Buffer}}
\subsubsection{\texorpdfstring{add\+Fragment()}{addFragment()}}
{\footnotesize\ttfamily void F\+Buffer\+::add\+Fragment (\begin{DoxyParamCaption}\item[{void $\ast$}]{bytes,  }\item[{std\+::size\+\_\+t}]{len }\end{DoxyParamCaption})}

add a new fragment to the \hyperlink{class_f_buffer}{F\+Buffer} check the fragment is inside address bounds of the managed \hyperlink{struct_m_buffer}{M\+Buffer} and that the new fragment is \char`\"{}past\char`\"{} (has a higher starting address) than the previously \char`\"{}last\char`\"{} fragment if this new fragment is contiguous with the \char`\"{}last\char`\"{} fragment consolidate the two if this new fragment is empty (len = 0) then do nothing \mbox{\Hypertarget{class_f_buffer_a64064a784e0ada0957d76db6c83b22fa}\label{class_f_buffer_a64064a784e0ada0957d76db6c83b22fa}} 
\index{F\+Buffer@{F\+Buffer}!copy\+In@{copy\+In}}
\index{copy\+In@{copy\+In}!F\+Buffer@{F\+Buffer}}
\subsubsection{\texorpdfstring{copy\+In()}{copyIn()}}
{\footnotesize\ttfamily void F\+Buffer\+::copy\+In (\begin{DoxyParamCaption}\item[{void $\ast$}]{bytes,  }\item[{std\+::size\+\_\+t}]{len }\end{DoxyParamCaption})}

copies these bytes into the \hyperlink{class_f_buffer}{F\+Buffer} so that they are continguous with (that is added to) the last fragement (fragment with the highest starting address) \mbox{\Hypertarget{class_f_buffer_a0987483eef377d599dcae38a6aac5236}\label{class_f_buffer_a0987483eef377d599dcae38a6aac5236}} 
\index{F\+Buffer@{F\+Buffer}!get\+M\+Buffer@{get\+M\+Buffer}}
\index{get\+M\+Buffer@{get\+M\+Buffer}!F\+Buffer@{F\+Buffer}}
\subsubsection{\texorpdfstring{get\+M\+Buffer()}{getMBuffer()}}
{\footnotesize\ttfamily \hyperlink{struct_m_buffer}{M\+Buffer}\& F\+Buffer\+::get\+M\+Buffer (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Return the underlying \hyperlink{struct_m_buffer}{M\+Buffer} \mbox{\Hypertarget{class_f_buffer_ae5f30d510287df8185bc30ecfd80840e}\label{class_f_buffer_ae5f30d510287df8185bc30ecfd80840e}} 
\index{F\+Buffer@{F\+Buffer}!size@{size}}
\index{size@{size}!F\+Buffer@{F\+Buffer}}
\subsubsection{\texorpdfstring{size()}{size()}}
{\footnotesize\ttfamily std\+::size\+\_\+t F\+Buffer\+::size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Returns the total size of all fragments 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
marvin/buffer/buffer.\+hpp\item 
marvin/buffer/buffer.\+cpp\end{DoxyCompactItemize}
