<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Client Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_client-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Client Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="client_8hpp_source.html">client.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afdde66898aa2cbfbdace6098de0f0800"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_client.html#afdde66898aa2cbfbdace6098de0f0800">Client</a> (boost::asio::io_service &amp;io, HttpHeader::SchemeType scheme, std::string server, std::string port)</td></tr>
<tr class="separator:afdde66898aa2cbfbdace6098de0f0800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e2ff6c5015bea27259c47b5948c2e7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_client.html#a17e2ff6c5015bea27259c47b5948c2e7">Client</a> (boost::asio::io_service &amp;io, std::string uri)</td></tr>
<tr class="separator:a17e2ff6c5015bea27259c47b5948c2e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e7eb95dbfbf747395904e04370c3b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_client.html#a71e7eb95dbfbf747395904e04370c3b3">Client</a> (boost::asio::io_service &amp;io, <a class="el" href="class_connection_interface.html">ConnectionInterface</a> *conn)</td></tr>
<tr class="separator:a71e7eb95dbfbf747395904e04370c3b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831c9bf9b4d6907ec23a04025810693f"><td class="memItemLeft" align="right" valign="top"><a id="a831c9bf9b4d6907ec23a04025810693f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Client</b> (const <a class="el" href="class_client.html">Client</a> &amp;other)=delete</td></tr>
<tr class="separator:a831c9bf9b4d6907ec23a04025810693f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a255f4905a3a0176a194e4a675d0a172b"><td class="memItemLeft" align="right" valign="top"><a id="a255f4905a3a0176a194e4a675d0a172b"></a>
<a class="el" href="class_client.html">Client</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_client.html">Client</a> &amp;)=delete</td></tr>
<tr class="separator:a255f4905a3a0176a194e4a675d0a172b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5886919756e3f0dcc4058ccb47ba44d6"><td class="memItemLeft" align="right" valign="top"><a id="a5886919756e3f0dcc4058ccb47ba44d6"></a>
MessageReaderSPtr&#160;</td><td class="memItemRight" valign="bottom"><b>getResponse</b> ()</td></tr>
<tr class="separator:a5886919756e3f0dcc4058ccb47ba44d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41106f498418bfd27f2acac18f154a5"><td class="memItemLeft" align="right" valign="top"><a id="af41106f498418bfd27f2acac18f154a5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setUrl</b> (std::string url)</td></tr>
<tr class="separator:af41106f498418bfd27f2acac18f154a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1dd3726ed7b178f6adcdc97523388d3"><td class="memItemLeft" align="right" valign="top"><a id="af1dd3726ed7b178f6adcdc97523388d3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setContent</b> (std::string &amp;contentStr)</td></tr>
<tr class="separator:af1dd3726ed7b178f6adcdc97523388d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af87e3114d4bff798cc9f16169319b576"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_client.html#af87e3114d4bff798cc9f16169319b576">setOnResponse</a> (ResponseHandlerCallbackType cb)</td></tr>
<tr class="separator:af87e3114d4bff798cc9f16169319b576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d175afa24c28766e3955f7039183b6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_client.html#a1d175afa24c28766e3955f7039183b6e">setOnHeaders</a> (ResponseHandlerCallbackType cb)</td></tr>
<tr class="separator:a1d175afa24c28766e3955f7039183b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e292408e166316e14651941c92f615"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_client.html#a73e292408e166316e14651941c92f615">setOnData</a> (ClientDataHandlerCallbackType cb)</td></tr>
<tr class="separator:a73e292408e166316e14651941c92f615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a272658b966e26a452eeaca461f8fd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_client.html#a7a272658b966e26a452eeaca461f8fd2">asyncConnect</a> (ErrorOnlyCallbackType cb)</td></tr>
<tr class="separator:a7a272658b966e26a452eeaca461f8fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d9c259aa4e1262987eb3d4e909565e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_client.html#a7d9c259aa4e1262987eb3d4e909565e2">asyncWrite</a> (MessageBaseSPtr requestMessage, ResponseHandlerCallbackType cb)</td></tr>
<tr class="separator:a7d9c259aa4e1262987eb3d4e909565e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc4752e98a0466c1dcbfb6791f1e226"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_client.html#a4cc4752e98a0466c1dcbfb6791f1e226">asyncWrite</a> (MessageBaseSPtr requestMessage, std::string &amp;body_str, ResponseHandlerCallbackType cb)</td></tr>
<tr class="separator:a4cc4752e98a0466c1dcbfb6791f1e226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3481f3e23665c4a4ddabd03eec6575d"><td class="memItemLeft" align="right" valign="top"><a id="ac3481f3e23665c4a4ddabd03eec6575d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>asyncWrite</b> (MessageBaseSPtr requestMessage, MBufferSPtr body_sptr, ResponseHandlerCallbackType cb)</td></tr>
<tr class="separator:ac3481f3e23665c4a4ddabd03eec6575d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7048efd28cbe37f69fc9a607e2d07852"><td class="memItemLeft" align="right" valign="top"><a id="a7048efd28cbe37f69fc9a607e2d07852"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>asyncWrite</b> (MessageBaseSPtr requestMessage, BufferChainSPtr chain_sptr, ResponseHandlerCallbackType cb)</td></tr>
<tr class="separator:a7048efd28cbe37f69fc9a607e2d07852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecccd1b8c74dc9c0df4e211a0625391b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_client.html#aecccd1b8c74dc9c0df4e211a0625391b">asyncWrite</a> (MessageBaseSPtr requestMessage, FBufferSharedPtr body, ResponseHandlerCallbackType cb)</td></tr>
<tr class="separator:aecccd1b8c74dc9c0df4e211a0625391b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a1654e97f9bd05ef1022076be0667c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_client.html#a41a1654e97f9bd05ef1022076be0667c">asyncWriteHeaders</a> (MessageBaseSPtr requestMessage, WriteHeadersCallbackType cb)</td></tr>
<tr class="separator:a41a1654e97f9bd05ef1022076be0667c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250fc2560b361f3fa3ef4a20061089d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_client.html#a250fc2560b361f3fa3ef4a20061089d9">asyncWriteBodyData</a> (void *dataBuffer, bool last, WriteBodyDataCallbackType cb)</td></tr>
<tr class="separator:a250fc2560b361f3fa3ef4a20061089d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55418abd09e5c887168d1fdf3bd9d1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_client.html#ab55418abd09e5c887168d1fdf3bd9d1f">asyncWriteTrailers</a> (MessageBaseSPtr requestMessage, AsyncWriteCallbackType cb)</td></tr>
<tr class="separator:ab55418abd09e5c887168d1fdf3bd9d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae60322d424fa33d49cd88e6bee08e7af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_client.html#ae60322d424fa33d49cd88e6bee08e7af">end</a> ()</td></tr>
<tr class="separator:ae60322d424fa33d49cd88e6bee08e7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac4838875e743af25125d8b5c8eba09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_client.html#a2ac4838875e743af25125d8b5c8eba09">close</a> ()</td></tr>
<tr class="separator:a2ac4838875e743af25125d8b5c8eba09"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a65270d4bec13972dc19c3eeab2b9c7a3"><td class="memItemLeft" align="right" valign="top"><a id="a65270d4bec13972dc19c3eeab2b9c7a3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>internalConnect</b> ()</td></tr>
<tr class="separator:a65270d4bec13972dc19c3eeab2b9c7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9775fe0ef908d59a5ab17e27caa8fd8"><td class="memItemLeft" align="right" valign="top"><a id="ab9775fe0ef908d59a5ab17e27caa8fd8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>internalWrite</b> ()</td></tr>
<tr class="separator:ab9775fe0ef908d59a5ab17e27caa8fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58ce4f6c733f1ecf42e4aa4007f52b2"><td class="memItemLeft" align="right" valign="top"><a id="ab58ce4f6c733f1ecf42e4aa4007f52b2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_async_write</b> (MessageBaseSPtr requestMessage, ResponseHandlerCallbackType cb)</td></tr>
<tr class="separator:ab58ce4f6c733f1ecf42e4aa4007f52b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299af80ea0a0a71458a7ca4c91bc6ae7"><td class="memItemLeft" align="right" valign="top"><a id="a299af80ea0a0a71458a7ca4c91bc6ae7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>putHeadersStuffInBuffer</b> ()</td></tr>
<tr class="separator:a299af80ea0a0a71458a7ca4c91bc6ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0d6b3a672370c201a24c839c5f7382"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_client.html#a6d0d6b3a672370c201a24c839c5f7382">setupUrl</a> (std::string url)</td></tr>
<tr class="separator:a6d0d6b3a672370c201a24c839c5f7382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a4105d8c58e9c8e2ca1919baca31026"><td class="memItemLeft" align="right" valign="top"><a id="a2a4105d8c58e9c8e2ca1919baca31026"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>defaultHeaders</b> ()</td></tr>
<tr class="separator:a2a4105d8c58e9c8e2ca1919baca31026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedea5f9f1f9fb7a8732dc982a0e629c9"><td class="memItemLeft" align="right" valign="top"><a id="aedea5f9f1f9fb7a8732dc982a0e629c9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setContentLength</b> ()</td></tr>
<tr class="separator:aedea5f9f1f9fb7a8732dc982a0e629c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a714da8195cfe69bbb8fa1f254cfa53cd"><td class="memItemLeft" align="right" valign="top"><a id="a714da8195cfe69bbb8fa1f254cfa53cd"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>_url</b></td></tr>
<tr class="separator:a714da8195cfe69bbb8fa1f254cfa53cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1bbfabad2a418db11741f9d6aef1de"><td class="memItemLeft" align="right" valign="top"><a id="ade1bbfabad2a418db11741f9d6aef1de"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>_uri</b></td></tr>
<tr class="separator:ade1bbfabad2a418db11741f9d6aef1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9080780007752190a708d566ed3a05f0"><td class="memItemLeft" align="right" valign="top"><a id="a9080780007752190a708d566ed3a05f0"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>_scheme</b></td></tr>
<tr class="separator:a9080780007752190a708d566ed3a05f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d16da0e37d8395bab50d56c82d6aef"><td class="memItemLeft" align="right" valign="top"><a id="a70d16da0e37d8395bab50d56c82d6aef"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>_server</b></td></tr>
<tr class="separator:a70d16da0e37d8395bab50d56c82d6aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b53e47e860f4656b348654643ddb76e"><td class="memItemLeft" align="right" valign="top"><a id="a9b53e47e860f4656b348654643ddb76e"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>_host</b></td></tr>
<tr class="separator:a9b53e47e860f4656b348654643ddb76e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0984cf4f6e5d4a99e72b7189ab50826f"><td class="memItemLeft" align="right" valign="top"><a id="a0984cf4f6e5d4a99e72b7189ab50826f"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>_host_with_port</b></td></tr>
<tr class="separator:a0984cf4f6e5d4a99e72b7189ab50826f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4671a4ffec3179a0ba4821b0d781b901"><td class="memItemLeft" align="right" valign="top"><a id="a4671a4ffec3179a0ba4821b0d781b901"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>_port</b></td></tr>
<tr class="separator:a4671a4ffec3179a0ba4821b0d781b901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c8113f51275dbb67633548399595ddc"><td class="memItemLeft" align="right" valign="top"><a id="a1c8113f51275dbb67633548399595ddc"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>_path</b></td></tr>
<tr class="separator:a1c8113f51275dbb67633548399595ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5a6400fbe272f8212a88155cf7deb5"><td class="memItemLeft" align="right" valign="top"><a id="a4f5a6400fbe272f8212a88155cf7deb5"></a>
Url::Query&#160;</td><td class="memItemRight" valign="bottom"><b>_query</b></td></tr>
<tr class="separator:a4f5a6400fbe272f8212a88155cf7deb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdcff50a83d67c071ebac089b21b16a1"><td class="memItemLeft" align="right" valign="top"><a id="afdcff50a83d67c071ebac089b21b16a1"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>_queryStr</b></td></tr>
<tr class="separator:afdcff50a83d67c071ebac089b21b16a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6461a9372edd60a8aba63ae5ccc082fb"><td class="memItemLeft" align="right" valign="top"><a id="a6461a9372edd60a8aba63ae5ccc082fb"></a>
boost::asio::io_service &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>_io</b></td></tr>
<tr class="separator:a6461a9372edd60a8aba63ae5ccc082fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a87fac91903111214bfc059a871a5ba"><td class="memItemLeft" align="right" valign="top"><a id="a4a87fac91903111214bfc059a871a5ba"></a>
MessageBaseSPtr&#160;</td><td class="memItemRight" valign="bottom"><b>_current_request</b></td></tr>
<tr class="separator:a4a87fac91903111214bfc059a871a5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61b6b1b65599c17c28f8627760ea684"><td class="memItemLeft" align="right" valign="top"><a id="ae61b6b1b65599c17c28f8627760ea684"></a>
MBufferSPtr&#160;</td><td class="memItemRight" valign="bottom"><b>_body_mbuffer_sptr</b></td></tr>
<tr class="separator:ae61b6b1b65599c17c28f8627760ea684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc69353f4a7afea1d9a485de18350c08"><td class="memItemLeft" align="right" valign="top"><a id="abc69353f4a7afea1d9a485de18350c08"></a>
FBufferSharedPtr&#160;</td><td class="memItemRight" valign="bottom"><b>_body_fbuffer_sptr</b></td></tr>
<tr class="separator:abc69353f4a7afea1d9a485de18350c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ba27f037924a099b13dcbace4425cc"><td class="memItemLeft" align="right" valign="top"><a id="a60ba27f037924a099b13dcbace4425cc"></a>
std::shared_ptr&lt; <a class="el" href="class_message_writer.html">MessageWriter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_wrtr</b></td></tr>
<tr class="separator:a60ba27f037924a099b13dcbace4425cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27fdd6a6489468f01efa06f8376bf9bb"><td class="memItemLeft" align="right" valign="top"><a id="a27fdd6a6489468f01efa06f8376bf9bb"></a>
std::shared_ptr&lt; <a class="el" href="class_message_reader.html">MessageReader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_rdr</b></td></tr>
<tr class="separator:a27fdd6a6489468f01efa06f8376bf9bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e06284228a92f6e91b00ef170fc6ae1"><td class="memItemLeft" align="right" valign="top"><a id="a4e06284228a92f6e91b00ef170fc6ae1"></a>
std::shared_ptr&lt; <a class="el" href="class_t_c_p_connection.html">TCPConnection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_conn_shared_ptr</b></td></tr>
<tr class="separator:a4e06284228a92f6e91b00ef170fc6ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3291b49a7c5c40886e31aa05a562602f"><td class="memItemLeft" align="right" valign="top"><a id="a3291b49a7c5c40886e31aa05a562602f"></a>
<a class="el" href="class_read_socket_interface.html">ReadSocketInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>_readSock</b></td></tr>
<tr class="separator:a3291b49a7c5c40886e31aa05a562602f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e33df170f88dbda08fe9cd0b3a0025"><td class="memItemLeft" align="right" valign="top"><a id="a02e33df170f88dbda08fe9cd0b3a0025"></a>
std::function&lt; void(Marvin::ErrorType &amp;err)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_goCb</b></td></tr>
<tr class="separator:a02e33df170f88dbda08fe9cd0b3a0025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d085507b14c836cbda0749ca2decb56"><td class="memItemLeft" align="right" valign="top"><a id="a8d085507b14c836cbda0749ca2decb56"></a>
ResponseHandlerCallbackType&#160;</td><td class="memItemRight" valign="bottom"><b>_response_handler</b></td></tr>
<tr class="separator:a8d085507b14c836cbda0749ca2decb56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab417dd0da30a89767811a717b5c6a14f"><td class="memItemLeft" align="right" valign="top"><a id="ab417dd0da30a89767811a717b5c6a14f"></a>
ResponseHandlerCallbackType&#160;</td><td class="memItemRight" valign="bottom"><b>_on_headers_handler</b></td></tr>
<tr class="separator:ab417dd0da30a89767811a717b5c6a14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af785f3d2d211634bf74dd35c5b523f75"><td class="memItemLeft" align="right" valign="top"><a id="af785f3d2d211634bf74dd35c5b523f75"></a>
ClientDataHandlerCallbackType&#160;</td><td class="memItemRight" valign="bottom"><b>_on_data_handler</b></td></tr>
<tr class="separator:af785f3d2d211634bf74dd35c5b523f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:abaaeecb3bd7e6e64684e894e64752cfc"><td class="memItemLeft" align="right" valign="top"><a id="abaaeecb3bd7e6e64684e894e64752cfc"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>traceClient</b> (<a class="el" href="class_client.html">Client</a> &amp;client)</td></tr>
<tr class="separator:abaaeecb3bd7e6e64684e894e64752cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f4b9cead705423379f0778f53e9d20"><td class="memItemLeft" align="right" valign="top"><a id="ad5f4b9cead705423379f0778f53e9d20"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>traceRequestMessage</b> (<a class="el" href="class_message_base.html">MessageBase</a> &amp;request)</td></tr>
<tr class="separator:ad5f4b9cead705423379f0778f53e9d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class implements an http client that can send a request message and wait for a response.</p>
<p>Two modes of transmission operation are provided for:</p>
<ul>
<li>send the entire request in a single call using asyncWrite. This mode is best when either there is NO message body or the entire message body is available at the time the request transmission is started. In this mode the handler provided to asyncWrite is passed a complete response including any body data.</li>
<li>send the request/message piecemeal - headers, followed by multiple chunks of body, followed by trailers. This mode is intended to handle streaming of the body data to avoid latency or buffering large body. In this mode the handler for the incoming response message is provide by the setOnResponseHandler. The response handler should be set before any transmission is started. A complete response including body data is provided to this handler.</li>
</ul>
<p>Two constructors are provided</p><ul>
<li>one will construct a non-connected client for which an explicit or implicit connect call will be required.</li>
<li>the other creates a client with an established connection.</li>
</ul>
<p>Handlers or callbacks </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afdde66898aa2cbfbdace6098de0f0800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdde66898aa2cbfbdace6098de0f0800">&#9670;&nbsp;</a></span>Client() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Client::Client </td>
          <td>(</td>
          <td class="paramtype">boost::asio::io_service &amp;&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HttpHeader::SchemeType&#160;</td>
          <td class="paramname"><em>scheme</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>server</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a client that is not connected - however give it the info it needs to try and establish a connection</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>- an io service </td></tr>
    <tr><td class="paramname">scheme</td><td>of type HttpHeader::SchemeType </td></tr>
    <tr><td class="paramname">server</td><td>- a string like google.com </td></tr>
    <tr><td class="paramname">port</td><td>- a string like "443" </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17e2ff6c5015bea27259c47b5948c2e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17e2ff6c5015bea27259c47b5948c2e7">&#9670;&nbsp;</a></span>Client() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Client::Client </td>
          <td>(</td>
          <td class="paramtype">boost::asio::io_service &amp;&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>uri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a client that is not connected - however give a url it needs to try and establish a connection. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>- an io service </td></tr>
    <tr><td class="paramname">url</td><td>- a string like "https://username:password@www.google.com/path1/path2:433?one=1111" </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71e7eb95dbfbf747395904e04370c3b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71e7eb95dbfbf747395904e04370c3b3">&#9670;&nbsp;</a></span>Client() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Client::Client </td>
          <td>(</td>
          <td class="paramtype">boost::asio::io_service &amp;&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_connection_interface.html">ConnectionInterface</a> *&#160;</td>
          <td class="paramname"><em>conn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a client with an established connection. In this case a call to connect will fail with an exception - as it is a logic error </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7a272658b966e26a452eeaca461f8fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a272658b966e26a452eeaca461f8fd2">&#9670;&nbsp;</a></span>asyncConnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Client::asyncConnect </td>
          <td>(</td>
          <td class="paramtype">ErrorOnlyCallbackType&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connects to the target host</p>
<hr/>
 <h2>implement connect </h2>

</div>
</div>
<a id="a7d9c259aa4e1262987eb3d4e909565e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d9c259aa4e1262987eb3d4e909565e2">&#9670;&nbsp;</a></span>asyncWrite() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Client::asyncWrite </td>
          <td>(</td>
          <td class="paramtype">MessageBaseSPtr&#160;</td>
          <td class="paramname"><em>requestMessage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResponseHandlerCallbackType&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes the complete message to the connected host inlcuding body and trailers (if there are any).</p>
<p>If not connected will perform a connect before transmitting the message. Will wait for a response and call the onResponseHandler CB when the response is complete.</p>
<p>If the request is to have a body it must be already attached to the <a class="el" href="class_message_interface.html">MessageInterface</a>. A content_length header will be attached by the client.</p>
<p>If the request is to have NO body use this method with the requestMessage.body == nullptr; </p>

</div>
</div>
<a id="a4cc4752e98a0466c1dcbfb6791f1e226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cc4752e98a0466c1dcbfb6791f1e226">&#9670;&nbsp;</a></span>asyncWrite() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Client::asyncWrite </td>
          <td>(</td>
          <td class="paramtype">MessageBaseSPtr&#160;</td>
          <td class="paramname"><em>requestMessage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>body_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResponseHandlerCallbackType&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The following are three ways to add a body to a request. The first two take a string or a shared pointer to an <a class="el" href="struct_m_buffer.html" title="MBuffer a contiguous buffer. ">MBuffer</a> - these are contiguous buffers and can be sent with a single asyncWrite </p>

</div>
</div>
<a id="aecccd1b8c74dc9c0df4e211a0625391b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecccd1b8c74dc9c0df4e211a0625391b">&#9670;&nbsp;</a></span>asyncWrite() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Client::asyncWrite </td>
          <td>(</td>
          <td class="paramtype">MessageBaseSPtr&#160;</td>
          <td class="paramname"><em>requestMessage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FBufferSharedPtr&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResponseHandlerCallbackType&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="class_f_buffer.html">FBuffer</a> is fragmented and requires multiple asyncWrite operations to send it </p>

</div>
</div>
<a id="a250fc2560b361f3fa3ef4a20061089d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a250fc2560b361f3fa3ef4a20061089d9">&#9670;&nbsp;</a></span>asyncWriteBodyData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Client::asyncWriteBodyData </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dataBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteBodyDataCallbackType&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transmits a block of body data - the data should NOT be chunk encode that will be done within the call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataBuffer</td><td>(type TBD) can also be nullptr </td></tr>
    <tr><td class="paramname">last</td><td>bool - signals this is the last dataBuffer and that the chunk trailer should be generated. </td></tr>
    <tr><td class="paramname">cb</td><td>- handler to be called when operation complete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>- asyncWriteBodyData( nullptr, true, ....) is the normal way to<ul>
<li>signal end of data, as the caller may not know its e-o-d until after the last buffer is sent. Such a call still sends data on the connection<ul>
<li>the chunk encoding trailer. </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a41a1654e97f9bd05ef1022076be0667c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41a1654e97f9bd05ef1022076be0667c">&#9670;&nbsp;</a></span>asyncWriteHeaders()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Client::asyncWriteHeaders </td>
          <td>(</td>
          <td class="paramtype">MessageBaseSPtr&#160;</td>
          <td class="paramname"><em>requestMessage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteHeadersCallbackType&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sends the first line and headers of the request message only and expects any body data to be sent using asyncWriteBodyData in which case the body will be "chunk" encoded and the headers will be completed to indicate this.</p>
<p>Dont use this method IF there is no body data, use asyncWrite </p>

</div>
</div>
<a id="ab55418abd09e5c887168d1fdf3bd9d1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55418abd09e5c887168d1fdf3bd9d1f">&#9670;&nbsp;</a></span>asyncWriteTrailers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Client::asyncWriteTrailers </td>
          <td>(</td>
          <td class="paramtype">MessageBaseSPtr&#160;</td>
          <td class="paramname"><em>requestMessage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AsyncWriteCallbackType&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>not yet implemented</p>
<p>This method should only be used if the transmission was started with a call to asyncWriteHeaders. The method asyncWrite handles trailers automatically.</p>
<p>Sends the trailers that are present in the requestMessage - trailers can be added to the message AFTER transmission has started as the internals of this class do not inspect the trailers until this call nor does it keep a copy of the original request </p>

</div>
</div>
<a id="a2ac4838875e743af25125d8b5c8eba09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ac4838875e743af25125d8b5c8eba09">&#9670;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Client::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>close - called to signal that connection::close has been received and that the net round trip should use a different connection for the next message. This invalidates _connection, _rdr, _wrtr</p>
<p>- not sure we need this - just delete the client object </p>

</div>
</div>
<a id="ae60322d424fa33d49cd88e6bee08e7af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae60322d424fa33d49cd88e6bee08e7af">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Client::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called to signal end-of-message. This function will (if necessary) add the chunk-encoding trailer. </p>

</div>
</div>
<a id="a73e292408e166316e14651941c92f615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73e292408e166316e14651941c92f615">&#9670;&nbsp;</a></span>setOnData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Client::setOnData </td>
          <td>(</td>
          <td class="paramtype">ClientDataHandlerCallbackType&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a handler to be called when a chunk of body data is available.</p>
<p>optional </p>

</div>
</div>
<a id="a1d175afa24c28766e3955f7039183b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d175afa24c28766e3955f7039183b6e">&#9670;&nbsp;</a></span>setOnHeaders()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Client::setOnHeaders </td>
          <td>(</td>
          <td class="paramtype">ResponseHandlerCallbackType&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a handler to be called when all headers have been received or if an error occurs while receiving a response message headers.</p>
<p>optional </p>

</div>
</div>
<a id="af87e3114d4bff798cc9f16169319b576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af87e3114d4bff798cc9f16169319b576">&#9670;&nbsp;</a></span>setOnResponse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Client::setOnResponse </td>
          <td>(</td>
          <td class="paramtype">ResponseHandlerCallbackType&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a handler to be called when a complete response message is received or if an error occurs while receiving a response message. </p>

</div>
</div>
<a id="a6d0d6b3a672370c201a24c839c5f7382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d0d6b3a672370c201a24c839c5f7382">&#9670;&nbsp;</a></span>setupUrl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Client::setupUrl </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>url</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> sets the url for the request, parses the url into components and saves them in particular deduces</p><ul>
<li>scheme</li>
<li>host - both with and without port appended</li>
<li>port</li>
<li>path/uri <h2>- query string </h2>
</li>
</ul>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>marvin/client/<a class="el" href="client_8hpp_source.html">client.hpp</a></li>
<li>marvin/client/client.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
